import java_cup.runtime.*;

/**
 * Universidad Simon Bolivar
 * Lenguajes de Programacion II
 * 
 * Maria Sol Ferrer 04-36975
 * Jamil Navarro 04-37334
 *
 * Proyecto: Procesador de lenguaje imperativo.
 * Leng2.cup: Analizador sintactico del lenguaje
 * 
 */

action code {:
    Bloque bloque = new Bloque(null);
:}

/**
 * Definicion de los tokens generados por el escaner
 * con el tipo asociado.
 */
terminal TokenValue COMIENZO;
terminal TokenValue FIN;
terminal TokenValue DECLENTERO;
terminal TokenValue DECLREAL;
terminal TokenValue DECLBOOL;
terminal TokenValue APARENT;
terminal TokenValue CPARENT; 
terminal OperadorB MAS;
terminal OperadorB MENOS;
terminal OperadorB POR;
terminal OperadorB ENTRE;
terminal OperadorB DIV;
terminal OperadorB MOD; 
terminal OperadorU TECHO;
terminal OperadorU PISO;
terminal OperadorU REDONDEAR;
terminal OperadorB YLOG;
terminal OperadorB OLOG;
terminal OperadorU NOLOG;
terminal OperadorB IGUAL;
terminal OperadorB DIF;
terminal OperadorB MAYOR;
terminal OperadorB MENOR;
terminal OperadorB MAYORIGUAL;
terminal OperadorB MENORIGUAL;
terminal TokenValue ASIGNACION; 
terminal TokenValue SI;
terminal TokenValue SINO;
terminal TokenValue FINSI;
terminal TokenValue HACER;
terminal TokenValue FINHACER;
terminal TokenValue ESCRIBIR;
terminal TokenValue LEER;
terminal TokenValue PYCOMA;
terminal TokenValue CIERTO;
terminal TokenValue FALSO;
		
terminal Integer NUMERO;
terminal String ID;
terminal Float REAL;

/**
 * Definicion de los simbolos no terminales de la
 * gramatica con el tipo de su atributo asociado.
 */
non terminal inicio;
non terminal Bloque bloq;
non terminal Bloque lInst;
non terminal Inst inst, Decl, iDeclA, iAsig, iSi, iSino, iHacer;
non terminal Expresion expr, fact;
non terminal Bloque inicB, finB;
non terminal TokenValue tipo;

/**
  * Orden de Precedencia
  */
precedence left IGUAL, DIF;
precedence left OLOG;
precedence left YLOG;
precedence left MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
precedence left MAS, MENOS;
precedence left POR, ENTRE, DIV, MOD;

/**
 * Gramatica del lenguaje.
 */
inicio	::= COMIENZO bloq:b FIN
        {: b.imprimirB(0); :}
		;

bloq    ::= inicB lInst finB:b {: RESULT = b; :}
        ;

inicB   ::= {: bloque = new Bloque(bloque); :}
        ;

finB    ::= {: Bloque b = bloque; bloque = bloque.getParent(); RESULT = b; :}
        ;

lInst	::= lInst inst:i 	{: bloque.agregarInst(i); :}
        |   inst:i 		    {: bloque.agregarInst(i); :}
        ;
		
inst	::= Decl:i		PYCOMA	{: RESULT = i; :}
		|	iDeclA:i	PYCOMA  {: RESULT = i; :}
        |   iAsig:i     PYCOMA	{: RESULT = i; :}
        |   iSi:i       		{: RESULT = i; :}
        |   iSino:i     		{: RESULT = i; :}
        |   iHacer:i    		{: RESULT = i; :}
        ;

Decl	::= tipo:t ID:i
		{:  Decl inst = new Decl(t.text, i);
			inst.esCorrecta(bloque);
			Informacion info = new Informacion(i,t.text,null);
			bloque.getTS().add(i,info);
            RESULT = null;
        :}
        ;

iDeclA	::= tipo:t ID:i ASIGNACION expr:e
		{:  Decl instd = new Decl(t.text, i);
			instd.esCorrecta(bloque);
			Informacion info = new Informacion(i,t.text,null);
            bloque.getTS().add(i,info);
			InstAsig inst = new InstAsig(i, e);
			inst.esCorrecta(bloque);			
            RESULT = inst;
        :}
        ;

tipo    ::= DECLENTERO:t    {: RESULT = t; :}
        |   DECLREAL:t      {: RESULT = t; :}
        |   DECLBOOL:t      {: RESULT = t; :}
        ;
	
iAsig	::= ID:d ASIGNACION expr:e
        {: InstAsig i = new InstAsig(d, e); i.esCorrecta(bloque); RESULT = i; :}
        ;

iSi	::= SI APARENT expr:e CPARENT bloq:l FINSI
		{: RESULT = new InstIf(e, l ); :}
        ;
		
iSino 	::= SI APARENT expr:e CPARENT bloq:l1 SINO bloq:l2 FINSI
		{: RESULT = new InstIfElse(e, l1,l2); :}
        ;
		
iHacer	::= HACER APARENT expr:e CPARENT bloq:l FINHACER
		{: RESULT = new InstDo(e, l); :}
        ;

expr	::= expr:e1 IGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.IGUAL, e2); :}
		|	expr:e1 DIF expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DESIGUAL, e2); :}
		|   expr:e1 OLOG expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.OR, e2); :}
		|   expr:e1 YLOG expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.AND, e2); :}
        |   expr:e1 MAYOR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MAYOR ,e2); :}
		|   expr:e1 MENOR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MENOR ,e2); :}
		|   expr:e1 MAYORIGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MAYORIGUAL ,e2); :}
		|   expr:e1 MENORIGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MENORIGUAL ,e2); :}
		|   expr:e1 MAS expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.SUMA ,e2); :}
		|   expr:e1 MENOS expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.RESTA ,e2); :}
		|   expr:e1 ENTRE expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DIVR ,e2); :}
		|   expr:e1 POR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MULT ,e2); :}
		|   expr:e1 DIV expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DIVE ,e2); :}
		|   expr:e1 MOD expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MOD ,e2); :}
		|	fact:f
		{:	RESULT = f; :}
        ;
	
fact	::= APARENT expr:e CPARENT 
		{:  RESULT = e; :}
        |   NUMERO:n 
		{:  RESULT = new Factor (TipoF.INT, n); :}
        |   MENOS fact:f 
		{:  RESULT = new ExprUna (OperadorU.MENOS, f); :}
        |   REAL:n 
		{:  RESULT = new Factor (TipoF.FLOAT, n); :}
        |   TECHO APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.TECHO, f); :}
        |   PISO APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.PISO, f); :}
        |   REDONDEAR APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.REDONDEO, f); :}
        |   NOLOG fact:f
		{:  RESULT = new ExprUna (OperadorU.NOT, f); :}
        |   ID:i 
		{:  Factor e = new Factor (TipoF.ID, i); RESULT = e; :}
        |   CIERTO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(true)); :}
        |   FALSO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(false)); :}
        ;
