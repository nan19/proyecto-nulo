import java_cup.runtime.*;
import java.lang.*;
import java.util.*;

/**
 * Universidad Simon Bolivar
 * Lenguajes de Programacion II
 * 
 * Maria Sol Ferrer 04-36975
 * Jamil Navarro 04-37334
 *
 * Proyecto: Procesador de lenguaje imperativo.
 * Leng2.cup: Analizador sintactico del lenguaje
 * 
 */

action code {:
    Bloque bloque = new Bloque(null);	
	boolean error = false;
:}

/**
 * Definicion de los tokens generados por el escaner
 * con el tipo asociado.
 */
 
terminal TokenValue FUNC;
terminal TokenValue FINFUNC;
terminal TokenValue PROC;
terminal TokenValue FINPROC;
terminal TokenValue ENTRADA;
terminal TokenValue ENTSAL;
terminal TokenValue SALIDA;
terminal TokenValue DOSPUNTOS;
terminal TokenValue COMIENZO;
terminal TokenValue FIN;
terminal TokenValue DECLENTERO;
terminal TokenValue DECLREAL;
terminal TokenValue DECLBOOL;
terminal TokenValue APARENT;
terminal TokenValue CPARENT;
terminal TokenValue ACORCH;
terminal TokenValue CCORCH;  
terminal TokenValue COMA;  
terminal OperadorB MAS;
terminal OperadorB MENOS;
terminal OperadorB POR;
terminal OperadorB ENTRE;
terminal OperadorB DIV;
terminal OperadorB MOD; 
terminal OperadorU TECHO;
terminal OperadorU PISO;
terminal OperadorU REDONDEO;
terminal OperadorB YLOG;
terminal OperadorB OLOG;
terminal OperadorU NOLOG;
terminal OperadorB IGUAL;
terminal OperadorB DIF;
terminal OperadorB MAYOR;
terminal OperadorB MENOR;
terminal OperadorB MAYORIGUAL;
terminal OperadorB MENORIGUAL;
terminal TokenValue ASIGNACION; 
terminal TokenValue SI;
terminal TokenValue SINO;
terminal TokenValue FINSI;
terminal TokenValue HACER;
terminal TokenValue FINHACER;
terminal TokenValue ESCRIBIR;
terminal TokenValue LEER;
terminal TokenValue PYCOMA;
terminal TokenValue CIERTO;
terminal TokenValue FALSO;
		
terminal Integer ENTERO;
terminal String ID;
terminal Float REAL;

/**
 * Definicion de los simbolos no terminales de la
 * gramatica con el tipo de su atributo asociado.
 */
non terminal inicio;
non terminal Bloque bloq;
non terminal Bloque lInst;
non terminal Inst inst, Decl, iDeclA, iAsig, iSi, iSino, iHacer;
non terminal Expresion expr, fact;
non terminal Bloque inicB, finB;
non terminal TipoF tipo;
non terminal Vector arreglo;
non terminal elem;
non terminal SubProgs;
non terminal SubProg;
non terminal Proc;
non terminal Func;
non terminal Vector Param;
non terminal Vector ParamE;
non terminal Vector ParamES;
non terminal Vector ParamS;
non terminal Vector LVar;

/**
  * Orden de Precedencia
  */
precedence left IGUAL, DIF;
precedence left OLOG;
precedence left YLOG;
precedence left MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
precedence left MAS, MENOS;
precedence left POR, ENTRE, DIV, MOD;

/**
 * Gramatica del lenguaje.
 */
inicio	::= SubProgs COMIENZO bloq:b FIN
        {: 	if (!error)
				b.imprimirB(0); 
		:}
		;

SubProgs::=	SubProgs SubProg
		|	
		;
		
SubProg	::=	Proc
		|	Func
		;
		
Proc	::= PROC ID:i APARENT Param:p CPARENT bloq:b FINPROC
			{:	b.getTS().addList(p);
				Informacion info = new Informacion(i, TipoF.PROC, b, 0);
				bloque.getTS().add(i, info);
			:}
		;

Func	::= FUNC tipo ID APARENT Param CPARENT bloq FINFUNC
		;
		
Param	::=	ParamE:p1 PYCOMA ParamES:p2 PYCOMA ParamS:p3
		{: p1.addAll(p2); p1.addAll(p3); RESULT = p1; :}
		|	ParamE:p1 PYCOMA ParamS:p2		{: p1.addAll(p2); RESULT = p1; :}
		|	ParamES:p1 PYCOMA ParamS:p2		{: p1.addAll(p2); RESULT = p1; :}
		|	ParamE:p1 PYCOMA ParamES:p2		{: p1.addAll(p2); RESULT = p1; :}
		|	ParamE:p						{: RESULT = p; :}
		|	ParamES:p						{: RESULT = p; :}
		|	ParamS:p						{: RESULT = p; :}
		;

ParamE	::=	ENTRADA DOSPUNTOS LVar:l 		{: RESULT = l; :}
		;
		
ParamES	::=	ENTSAL DOSPUNTOS LVar:l 		{: RESULT = l; :}
		;
		
ParamS	::=	SALIDA DOSPUNTOS LVar:l 		{: RESULT = l; :}
		;

LVar	::=	LVar:l COMA tipo:t ID:i
		{:	Informacion info = new Informacion(i, t, null, 0);
			l.add(info);
			RESULT = l;
		:}
		|	tipo:t ID:i				
		{: 	Vector v = new Vector();
			Informacion info = new Informacion(i, t, null, 0);
			v.add(info);
			RESULT = v;
		:}
		;
		
bloq    ::= inicB lInst finB:b {: RESULT = b; :}
        ;

inicB   ::= {: bloque = new Bloque(bloque); :}
        ;

finB    ::= {: Bloque b = bloque; bloque = bloque.getParent(); RESULT = b; :}
        ;

lInst	::= lInst inst:i 	{: bloque.agregarInst(i); :}
        |   inst:i 		    {: bloque.agregarInst(i); :}
        ;
		
inst	::= Decl:i		PYCOMA	{: RESULT = i; :}
		|	iDeclA:i	PYCOMA  {: RESULT = i; :}
        |   iAsig:i     PYCOMA	{: RESULT = i; :}
        |   iSi:i       		{: RESULT = i; :}
        |   iSino:i     		{: RESULT = i; :}
        |   iHacer:i    		{: RESULT = i; :}
        ;

Decl	::= tipo:t ID:i
		{:  Decl inst = new Decl(t, i );	
			Informacion info = new Informacion(i,t,null, 0);
			error = inst.esCorrecta(bloque,info);			
			if (bloque.getTS().get(i ) == null) 
				bloque.getTS().add(i ,info);
            RESULT = inst;
        :}		
		|	ACORCH ENTERO:e CCORCH tipo:t ID:i				
        ;

iDeclA	::= tipo:t ID:i ASIGNACION expr:e
		{:  Decl inst = new Decl(t, i );	
			Informacion info = new Informacion(i,t,e,0);
			error = inst.esCorrecta(bloque, info);
			if (bloque.getTS().get(i) == null) 
				bloque.getTS().add(i,info);	
				
			InstAsig insta = new InstAsig(i, e); 					
			error = insta.esCorrecta(bloque, info);				
			RESULT = insta;
        
        :}
		|	ACORCH CCORCH tipo:t ID:i ASIGNACION ACORCH arreglo:a CCORCH		
        ;

tipo    ::= DECLENTERO:t    {: RESULT = TipoF.INT; :}
        |   DECLREAL:t      {: RESULT = TipoF.FLOAT; :}
        |   DECLBOOL:t      {: RESULT = TipoF.BOOL; :}
        ;
		
iAsig	::= ID:d ASIGNACION expr:e
        {: 	InstAsig i = new InstAsig(d , e); 
			Informacion info = new Informacion(d,TipoF.INT,e,0);			
			error = i.esCorrecta(bloque, info);				
			RESULT = i; 
		:}
		|	ID:d ASIGNACION ACORCH arreglo:a CCORCH        
        ;

arreglo	::= arreglo:a COMA elem:e
		{:	a.add(e);
			RESULT = a;
		:}
		|	elem:e
		{: 	Vector v = new Vector();
			v.add(e);
			RESULT = v;
		:}
		;
		
elem	::=	ENTERO:e		{: RESULT = new Integer(e); :}
		|	REAL:e			{: RESULT = new Float(e); :}
		|	CIERTO:e		{: RESULT = new Boolean(true); :}
		|	FALSO:e			{: RESULT = new Boolean(false); :}
		|	ID:e			{: RESULT = e; :}
		;
		
iSi	::= SI APARENT expr:e CPARENT bloq:l FINSI
		{: RESULT = new InstIf(e, l ); :}
        ;
		
iSino 	::= SI APARENT expr:e CPARENT bloq:l1 SINO bloq:l2 FINSI
		{: RESULT = new InstIfElse(e, l1,l2); :}
        ;
		
iHacer	::= HACER APARENT expr:e CPARENT bloq:l FINHACER
		{: RESULT = new InstDo(e, l); :}
        ;

expr	::= expr:e1 IGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.IGUAL, e2); :}
		|	expr:e1 DIF expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DESIGUAL, e2); :}
		|   expr:e1 OLOG expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.OR, e2); :}
		|   expr:e1 YLOG expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.AND, e2); :}
        |   expr:e1 MAYOR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MAYOR ,e2); :}
		|   expr:e1 MENOR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MENOR ,e2); :}
		|   expr:e1 MAYORIGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MAYORIGUAL ,e2); :}
		|   expr:e1 MENORIGUAL expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MENORIGUAL ,e2); :}
		|   expr:e1 MAS expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.SUMA ,e2); :}
		|   expr:e1 MENOS expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.RESTA ,e2); :}
		|   expr:e1 ENTRE expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DIVR ,e2); :}
		|   expr:e1 POR expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MULT ,e2); :}
		|   expr:e1 DIV expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.DIVE ,e2); :}
		|   expr:e1 MOD expr:e2
		{:  RESULT = new ExprBin(e1, OperadorB.MOD ,e2); :}
		|	fact:f
		{:	RESULT = f; :}
        ;
	
fact	::= APARENT expr:e CPARENT 
		{:  RESULT = e; :}
        |   ENTERO:n 
		{:  RESULT = new Factor (TipoF.INT, n); :}
        |   MENOS fact:f 
		{:  RESULT = new ExprUna (OperadorU.MENOS, f); :}
        |   REAL:n 
		{:  RESULT = new Factor (TipoF.FLOAT, n); :}
        |   TECHO APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.TECHO, f); :}
        |   PISO APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.PISO, f); :}
        |   REDONDEO APARENT fact:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.REDONDEO, f); :}
        |   NOLOG fact:f
		{:  RESULT = new ExprUna (OperadorU.NOT, f); :}
        |   ID:i 
		{:  Factor e = new Factor (TipoF.ID, i ); RESULT = e; :}
        |   CIERTO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(true)); :}
        |   FALSO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(false)); :}
        ;
