import java_cup.runtime.*;

/**
 * Universidad Simon Bolivar
 * Lenguajes de Programacion II
 * 
 * Maria Sol Ferrer 04-36975
 * Jamil Navarro 04-37334
 *
 * Proyecto: Procesador de lenguaje imperativo.
 * Leng2.cup: Analizador sintactico del lenguaje
 * 
 */

action code {:
    Bloque bloque = new Bloque(null);
:}



/**
 * Definicion de los tokens generados por el escaner
 * con el tipo asociado.
 */
terminal TokenValue COMIENZO;
terminal TokenValue FIN;
terminal TokenValue DECLENTERO;
terminal TokenValue DECLREAL;
terminal TokenValue DECLBOOL;
terminal TokenValue APARENT;
terminal TokenValue CPARENT; 
terminal OperadorB MAS;
terminal OperadorB MENOS;
terminal OperadorB POR;
terminal OperadorB ENTRE;
terminal OperadorB DIV;
terminal OperadorB MOD; 
terminal OperadorU TECHO;
terminal OperadorU PISO;
terminal OperadorU REDONDEAR;
terminal OperadorB YLOG;
terminal OperadorB OLOG;
terminal OperadorU NOLOG;
terminal OperadorB IGUAL;
terminal OperadorB DIF;
terminal OperadorB MAYOR;
terminal OperadorB MENOR;
terminal OperadorB MAYORIGUAL;
terminal OperadorB MENORIGUAL;
terminal TokenValue ASIGNACION; 
terminal TokenValue SI;
terminal TokenValue SINO;
terminal TokenValue FINSI;
terminal TokenValue HACER;
terminal TokenValue FINHACER;
terminal TokenValue ESCRIBIR;
terminal TokenValue LEER;
terminal TokenValue PYCOMA;
terminal TokenValue CIERTO;
terminal TokenValue FALSO;
		
terminal Integer NUMERO;
terminal String ID;
terminal Float REAL;

/**
 * Definicion de los simbolos no terminales de la
 * gramatica con el tipo de su atributo asociado.
 */
non terminal Bloque s, bloq;
non terminal Bloque lInst;
non terminal Bloque inst;
non terminal Bloque iDecl;
non terminal Bloque iDeclA;
non terminal Bloque iAsig;
non terminal Bloque iSi;
non terminal Bloque iSino;
non terminal Bloque iHacer;
non terminal Expresion expr, expr2, term, fact, fact2, fact3;
non terminal OperadorB oBinEq, oBin, oBin2, oBinC;
non terminal Bloque inicB, finB;

/**
 * Gramatica del lenguaje.
 */

s	::= COMIENZO bloq FIN
            {: RESULT = bloque; :}
	;

bloq    ::= inicB lInst finB:b {: RESULT = b; :}
        ;

inicB   ::= {: bloque = new Bloque(bloque); :}
        ;

finB    ::= {: bloque.imprimir(); Bloque b = bloque; bloque = bloque.getParent(); RESULT = b; :}
        ;

lInst	::= lInst inst PYCOMA
        |   inst PYCOMA
        ;
		
inst	::= iDecl
        |   iDeclA
        |   iAsig
        |   iSi
        |   iSino
        |   iHacer
        ;

iDecl	::= DECLENTERO:t ID:i
		{:   Informacion info = new Informacion(i,t.text,null);
                     bloque.getTS().add(i,info);
                     bloque.agregarInst(new InstDecl(t.text, i));
                :}
        |   DECLREAL:t ID:i
		{:  Informacion info = new Informacion(i,t.text,null);
                    bloque.getTS().add(i,info);
                    bloque.agregarInst(new InstDecl(t.text, i)); 
                :}
        |   DECLBOOL:t ID:i
		{:  Informacion info = new Informacion(i,t.text,null);
                    bloque.getTS().add(i,info);
                    bloque.agregarInst(new InstDecl(t.text, i)); 
                :}
        ;
		
iDeclA	::= DECLENTERO:t ID:i ASIGNACION expr:e
		{:  Informacion info = new Informacion(i,t.text,null); //null hay q reemplazarlo
                    bloque.getTS().add(i,info);
                    bloque.agregarInst(new InstDeclAsig(t.text, i,e )); 
                :}
        |   DECLREAL:t ID:i ASIGNACION expr:e
		{:  Informacion info = new Informacion(i,t.text,null); //null hay q reemplazarlo
                    bloque.getTS().add(i,info);
                    bloque.agregarInst(new InstDeclAsig(t.text,i,e )); 
                :}
        |   DECLBOOL:t ID:i ASIGNACION expr:e
		{:  Informacion info = new Informacion(i,t.text,null); //null hay q reemplazarlo
                    bloque.getTS().add(i,info);
                    bloque.agregarInst(new InstDeclAsig(t.text, i,e )); 
                :}
        ;
	
iAsig	::= ID:d ASIGNACION expr:e
                {:  
                    bloque.agregarInst(new InstAsig(d, e)); 
                :}
        ;

iSi	::= SI APARENT expr:e CPARENT bloq:l FINSI
		{:  bloque.agregarInst(new InstIf(e, l ));
                :}
        ;
		
iSino 	::= SI APARENT expr:e CPARENT bloq:l1 SINO bloq:l2 FINSI
		{:  bloque.agregarInst(new InstIfElse(e, l1,l2)); 
                :}
        ;
		
iHacer	::= HACER APARENT expr:e CPARENT bloq:l FINHACER
		{:  bloque.agregarInst(new InstDo(e, l)); :}
        ;

expr	::= expr:e1 oBinEq:o expr2:e2
		{:  RESULT = new ExprBin(e1, o, e2); :}
        |   expr2:e
		{:  RESULT = e; :}
        ;
		
oBinEq  ::=  IGUAL  {: RESULT = OperadorB.IGUAL; :}
        |    DIF    {: RESULT = OperadorB.DESIGUAL; :}
        ;

expr2	::= expr2:e1 oBin:o term:e2
		{:  RESULT = new ExprBin(e1, o ,e2); :}
        |   term:t
		{:  RESULT = t; :}
        ;

oBin    ::= MAS     {: RESULT = OperadorB.SUMA;  :}
        |   MENOS   {: RESULT = OperadorB.RESTA; :}
        |   OLOG    {: RESULT = OperadorB.OR;    :}
        ;

term	::= term:e1 oBin2:o fact:e2
		{: RESULT = new ExprBin(e1, o, e2); :}	
        |   fact:f
		{: RESULT = f; :}
        ;

oBin2   ::= ENTRE   {: RESULT = OperadorB.DIVR; :}
        |   POR     {: RESULT = OperadorB.MULT; :}
        |   YLOG    {: RESULT = OperadorB.AND; :}
        |   DIV     {: RESULT = OperadorB.DIVE; :}
        |   MOD     {: RESULT = OperadorB.MOD; :}
        ;

fact	::= fact:e1 oBinC:o fact3:e2
		{: RESULT = new ExprBin(e1, o, e2); :}
        |   fact3:f
		{: RESULT = f; :}
        ;

oBinC  ::=  MAYOR       {: RESULT = OperadorB.MAYOR; :}
        |   MENOR       {: RESULT = OperadorB.MENOR; :}
        |   MAYORIGUAL  {: RESULT = OperadorB.MAYORIGUAL; :}
        |   MENORIGUAL  {: RESULT = OperadorB.MENORIGUAL; :}
	;
	
fact3	::= APARENT expr:e CPARENT 
		{:  RESULT = e; :}
        |   NUMERO:n 
		{:  RESULT = new Factor (TipoF.INT, n); :}
        |   MENOS fact3:f 
		{:  RESULT = new ExprUna (OperadorU.MENOS, f); :}
        |   REAL:n 
		{:  RESULT = new Factor (TipoF.FLOAT, n); :}
        |   TECHO APARENT fact3:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.TECHO, f); :}
        |   PISO APARENT fact3:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.PISO, f); :}
        |   REDONDEAR APARENT fact3:f CPARENT
		{:  RESULT = new ExprUna (OperadorU.REDONDEO, f); :}
        |   NOLOG fact3:f
		{:  RESULT = new ExprUna (OperadorU.NOT, f); :}
        |   ID:i 
		{:  Factor e = new Factor (TipoF.ID, i); RESULT = e; :}
        |   CIERTO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(true)); :}
        |   FALSO:c 
		{: RESULT= new Factor(TipoF.BOOL, new Booleano(false)); :}
        ;
